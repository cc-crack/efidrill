# Efidrill Write Paper

## 1 引言

### 1.1 摘要

将数据流追踪分析方法应用到UEFI漏洞挖掘，通过分析Use-Def变量对应关系和IR程序上下文，标记还原出数据的传递路径；通过特殊汇编指令预测变量数值区间，在此基础上发布了UEFI漏洞挖掘工具EFIDRILL，通过工具产出的多个0Day漏洞，验证了数据流追踪分析方法在UEFI漏洞挖掘领域也非常有效。UEFI一直是电脑启动的早期阶段，针对UEFI的攻击可以破坏电脑启动的Secure
Boot机制，从而插入UEFI Rootkit。由于这类Rootkit存在于SMM或者BootLoader中，因此可以长期隐秘的控制受害者的电脑，随着”黑莲花“的出现，针对UEFI的攻击利用已经不再仅仅是一个神话。

在过去的几年中，随着针对UEFI的安全研究不断进行，安全研究者发现了许多SMM漏洞，这也进一步提升了UEFI的安全性，诸如efiexplorer等工具的问世，也极大的简化了UEFI固件的逆向成本。

许多UEFI漏洞隐藏的十分深入，现有的UEFI漏洞挖掘工具聚焦于Fuzz或者简单的匹配汇编指令，没有一个公开的工具可以能够基于数据流追踪分析的方法，自动化的检测发现UEFI中的安全漏洞。为此我们提出了首个公开的对UEFI固件进行数据流分析的开源
IDA 插件——EfiDrill。所提供的 IDA
插件通过数据流追踪，具备对UEFI固件进行污点追踪，结构体自动化分析，变量数值预测，自动化漏洞识别等功能。并在来自常见供应商（如华硕、因特尔、戴尔、惠普等）的硬件平台中发现了多个以前未报告的漏洞。

### 1.2 SMM模式介绍

系统管理模式（System Management
mode）（以下简称SMM）是Intel引入x86体系结构的一种CPU的执行模式。系统管理模式只能通过系统管理中断进入，并只能通过执行RSM指令退出。SMM模式对操作系统透明，被称为ring-2。如果恶意攻击者能够拿到SMM的控制权，那么恶意攻击者就可以绕过secure
boot，获取bitlocker密钥，或者种植一个操作系统无法感知的rootkit。

SMM存在许多攻击面，经过我们的整理，我们确认了系统启动以后的攻击面如下：

- CommBuffer可以携带外部数据，然后通过对应的GUID，可以在child smi中被使用
- 同样的SMI请求的port号和data号也可能作为数据被SWSMI解析
- SMRAM外部的物理地址例如0x40E同样会在兼容legacy的时候被SMM使用，即使它可能并不安全
- Getvariable类获取的数据可能在启动阶段或者Setvariable等函数修改，它同样是不安全的
- 一些Runtime Service接口，它们本身被存储在SMM外部，在SMM中调用这个接口将触发call out
- 在SMI请求中能够通过ReadSaveState获取调用时的寄存器信息，然而这个寄存器的值本身并不一定可信

通过上述的接口，SMM外的代码可以将数据传入SMM中，当SMM代码不正确的处理这些数据时便会存在漏洞。

### 1.3 目标

我们试图通过一种新的方法来自动化的深入挖掘UEFI漏洞，通过这种方法，可以深入挖掘复杂的UEFI漏洞。同时我们希望我们的工具能够辅助我们对固件进行分析的工作，自动化的生成结构体并用于模糊测试和逆向工程。我们将提出我们的新工具，并将其做成一个IDA插件。

### 1.4 EfiDrill介绍

我们开源了我们的工具EFIDrill，这个工具具备数据流追踪的功能，它可以对SMM外部数据进行污点追踪，结构体分析，漏洞识别，数值预测等。通过这个工具，我们在大约1个月的时间里发现了几十个UEFI固件的BUG，并且其中的十多个被各家知名厂商作为漏洞接受。我们在此完全开源我们的工具，并且我们将我们的工具做成一个IDA插件，以便您可以方便的使用它。

### 1.5 贡献

#### 1.5.1 构建数据流分析模块

我们的工具**实现了针对UEFI的数据流追踪分析模块**
，该模块分析由汇编转译的IR语言中的use-def变量对应关系，以及IR程序上下文来判断数据的传递路径，通过数据传递路径，判断数据是否可以被控制。

#### 1.5.2 构建数值分析模块

我们**实现了数值分析模块**，通过判断CMP、XOR等一些列特殊的汇编指令，分析一个变量可能的数值范围，用于判断一个变量在一个分支中是否被限制在指定的数值范围之内，这能够帮助发现存在脆弱性的代码。

#### 1.5.3 漏洞挖掘插件的开发

利用前文的数据流追踪分析方法，我们开发了TOC-TOU、SMMOOB等7个插件，可用于检测UEFI中对应的7种存在于代码中的薄弱环节。其他人可以基于这些可继承的插件，继续扩展检测范围和对象。

#### 1.5.4 结构体类型预测

基于前文的数据流追踪分析方法，我们可以对SMM外部输入的数据进行自动化的结构体类型重建，当进行模糊测试时，这些自动重建的结构体类型可以用于更好的发生种子生成。

### 1.6 成果

我们找到了许多此前未被发现的未公开漏洞，它们中的一部分甚至来自于UEFI固件供应商，所以有理由相信，它们广泛的存在于各种不同厂商的固件中。

- Vulnerability in DELL T7920
- Vulnerability in DELL T7920
- Vulnerability in DELL T7910
- OOB Vulnerability in ASUS D900MD
- OOB Vulnerability in ASUS D900MD
- INTEL-W54FWSHJ
- INTEL-8T9BT8MW
- INTEL-G4O15ERY
- INTEL-T0WK2MUJ
- INTEL-EUCZ5F1V

除此之外我们还发现了一些供应链的问题，这些问题可能曾经在其他平台上被发现过，或者在当前平台上已经修补过，但是仍然存在使用旧版本的固件，已知但未修复，修复但有问题的情况，导致安全问题仍然存在。这些旧版本的固件可能是非供应商编译的，所以通过哈希特征匹配同样很难发现他们

- INTEL-6AYUD87U
- INTEL-VAJCIV59
- CVE-2021-33164（ASUS）

## 2 UEFI固件静态分析技术

### 2.1 静态分析概述

静态漏洞挖掘技术指在不运行目标程序的前提下对目标程序进行分析，这里又可以分为针对源码以及针对二进制程序进行分析其词法、语法、语义等，并通过相关工具获得其AST,
CFG, DDG, PDG, CPG等进行辅助分析固件的执行逻辑，来进行漏洞挖掘。

### 2.2 静态分析技术在UEFI固件分析中的应用

通过静态分析技术，我们可以在没有设备和调试能力的情况下发现UEFI安全问题，并且静态分析可以帮助我们更好的理解代码的逻辑，许多在模糊测试下难以触发的代码逻辑，可以通过静态分析技术发现。现在公开的UEFI静态分析工具例如IDA,UEFI
Tool大多关注于对于固件符号的恢复，这很大程度上的降低了人工审计的的难度，而另一方面例如efiXloader等工具通过匹配Double
Getvariable，runtime serice调用等行为进行自动化静态漏洞挖掘，可以更好的大规模发现UEFI固件中的漏洞。

### 2.3 UEFI固件静态分析挑战

然而通过静态分析挖掘漏洞的挑战却仍然存在，静态的BIOS固件分析需要在无源码的情况下进行，并且SMM可以从CommBuffer，ReadSaveState，SMRAM外部内存，gBS，gRT等多个地方获取外部输入并进行复杂处理。这种情况大多数时候只能人工应对，自动化工具很难深入挖掘UEFI漏洞。

如前文所提到的，在已知的UEFI漏洞检测工具中，已经有静态分析工具efiXplorer这样的自动化漏洞挖掘工具。但是还没有公开的工具，能够基于数据流追踪分析的方法，自动化的检测发现UEFI中的安全漏洞。

在我们多年基于污点追踪技术的软件漏洞挖掘经验中，我们发现，通过可达定义分析算法，可以在有限的开销内，对关键指令和关键数据进行定位，因此我们通过可达定义分析算法和上下文分析来进行数据流追踪。

## 3 工具设计与实现

### 3.1 架构概述

为了能够清晰的描述我们的工具，我们在这里说明我们工具的架构并给出我们的架构图，我们从我们的调度，分析，漏洞挖掘三个大功能将我们的工具分成如下几个部分：

- 管理调度层，该层包含了所有的待分析函数列表和分析插件控制
- 数据流分析层，该层用于处理具体分析工作，它将处理具体的每条分析工作，进行变量数值预测和数据流关系的保存
- 检测插件层，该层会分析当前函数中是否存在对应规则的问题

### 3.2 分析引擎构建

#### 3.2.1 通过可达定义分析算法构建数据和路径的use-def链条

作为我们工作的第一步，我们需要先将我们的固件进行逆向，并且将逆向生成的汇编代码转换成为ir语言，接着我们通过可达定义分析构建数据的use-def集合和进行地址可达性分析。我们通过如下步骤完成上述工作：

- 我们首先将二进制程序的汇编代码以函数为单位抽象出了IR语言

- 接着针对每一个函数，我们通过使用可达定义分析算法构建出当前函数在每一个地址上的use-def变量

- 通过将地址作为def变量并进行可达定义分析，我们可以找到两个地址之间是否存在可达路径

- 同时为了能够分析函数间的变量传递关系，当我们遇到函数调用时，我们将函数作为代码块，进行use-def分析。

#### 3.2.2 通过上下文分析和别名分析进行数据流追踪

接着我们需要通过上下文分析和别名分析来对SMM外部可控的变量进行标注，我们通过如下步骤完成上述工作：

- 查找指定函数中SMM外部可控的初始变量作为我们追踪列表中最开始的部分。

- 通过分析上下文生找到use-def变量的传递数据流关系。

- 通过别名分析算法，我们将部分变量识别成另一个变量的别名。

- 我们将不断地添加新的变量到我们SMM外部可控变量的列表中

#### 3.2.3 初始SMM外部可控变量标注

为了能够更加全面的发现UEFI固件漏洞，我们总结了我们能找到的所有可能的来源于SMM外部的攻击面，我们将按照前文所述将所有这些SMM外不可控的攻击面所对应的变量作为我们的初始变量。这些攻击面如下所示：

- CommBuffer and CommBufferSize

- ReadSaveState

- 0xc0000以下的绝对跳转

- gRT和gBS

- Getvariable的Datasize和Data

- 父函数传递进来的参数

#### 3.2.3 变量数值预测

为了能够进一步的提高分析的准确性，我们还提供了简单的数值预测功能，通过对特定语法的解析，我们可以预测一个变量在某个分支上可能的数值，通过这种方法，我们可以判断诸如MemCopy和SmmBufferValidation，callout等调用发生时，变量是否必须等于有限约束的范围内的数据，从而发现脆弱性代码。

###  

### 3.3 检测插件的实现

#### 3.3.1 callout检测

目前已有的检测方法，均为判断call中是否包含gRT与gBS，然而将诸如0x40E地址，CommBuffer，ReadSaveState返回，Getvariable返回当作函数调用参数地址的行为同样会导致CallOut发生，我们可以通过判断跳转发生时，其中包含的参数变量是否为SMM外部可控来找到这种漏洞。

#### 3.3.2 Get variable溢出检测

目前已有的检测方法，通过判断datasize是否进行初始化或者是否存在double
Getvariable来判断是否存在漏洞，然而，通过SMM外部可控数据传递进来的datasize同样会造成变量长度不可控，从而导致缓冲区溢出。我们同样通过判断datasize参数是否为SMM外部传递进来的可控数据流来判断是否存在漏洞。

#### 3.3.3 SMM OOB检测

SMRAM OOB是一种常见的安全问题，开发者往往可以通过SmmBufferValidation 或者
amiSmmBufferValidation来进行检测，从而避免这种安全问题。我们的脚本会找到可能的SmmBufferValidation函数，然后通过查看长度参数的是否存在数值约束范围来判断是否对某一个输入数据的指定长度进行检测。当我们发现了一个SMM外部输入数据的指定偏移被使用时，我们会判断在所有可达路径上记录的SmmBufferValidation检测长度是否小于当前偏移来找到这种漏洞。

#### 3.3.4 TOCTOU检测

对于长度的检测不是万能的，TOCTOU漏洞正是通过绕过长度检测来利用的。这种漏洞通过外部设备（入GPU，磁盘IO）修改一个被检测过的内存。我们通过判断一个SMM外部输入数据被当作指针时，指定偏移所对应的内存是否被多次使用来找到这种漏洞。

#### 3.3.5 MEMCOPY溢出检测

不止Getvarable会导致溢出，当一个SMM外部可控数据被拷贝时同样会发生溢出。我们通过和检测SMM
OOB漏洞类似的方法来检测这种漏洞，当我们发现拷贝长度来自外部可控数据时，我们会认为这种漏洞发生。

#### 3.3.6 脆弱性检测：SMM外部数据存入全局变量检测

部分代码中存在将一个SMM外部的数据传入SMM的全局变量中来留作之后使用，然而，将一个指针传入全局变量可能导致风险，因为开发者在使用这种全局变量时并不总能意识到这个指针是不可信的，我们通过判断一个可控指针（数据）是否传入全局变量来识别可能的风险。

#### 3.3.7 脆弱性检测：间接调用参数为外部输入检测

部分代码中存在将一个SMM外部的数据作为间接调用的参数来使用，然而由于这种间接调用的函数处理者不一定能够意识到这个输入源自于SMM外部的不可信数据，从而导致可能的问题，在这种情况中，我们同样在间接调用发生时，判断其参数的变量是否是SMM外部数据可控的，来找到这种风险。

### 3.4 结构体类型自动化分析

对于Fuzz或者逆向我们往往需要知道SMM外部输入数据的结构体类型，从而理解一个SMM外部输入数据被怎样使用，以及是否存在问题。当一个内存被使用时，它会包含如下属性。

- 使用的寄存器
- 使用的偏移
- 取址符

我们记录下这个寄存器作为基地址所使用的数值偏移，且记录下这个偏移被使用时所定义的新的可达定义变量，这样我们就可以形成一个由可达定义的变量所形成的多叉树。如果列表中的一个可达定义变量被当作一个指针使用时（也就是说它父节点的的指定偏移里面的数据被当作了基地址），那么我们就可以判断这个可达定义变量是一个指针类型，存储了这个节点的父节点中对应的偏移就会被当作一个存储指针的变量类型。

同时为了应对联合问题，我们会记录一个节点对应的可达地址范围，通过这个来判断它是不是同一个路径分支下的同类型变量，以描述一个输入可能的多个结构类型。

当进行模糊测试时，这些自动重建的结构体类型可以用于更好的发生种子生成。

### 3.5 扩展插件

为了能够方便以后修改和扩展我们的插件，我们留下了若干个回调和类来用作扩展。

我们提供了函数处理回调来解决外部调用通过继承User_Function_Define并实现如下函数，您可以处理和修复外部调用的函数和初始化变量逻辑

- function_call_fix
- user_def_check

同时也可以添加新的检测插件，我们的工具通过在添加use-def变量到追踪列，处理每一句代码，函数调用发生时，所有函数分析结束时分别调用不同的回调来供扩展

- add_interesting_memory_map_list
- vulnerability_find
- copy_use_var
- finish_work

### 3.6 大规模测试

为了能够减少人力研究的成本，我们提供了大规模自动化测试脚本，我们的脚本可以提供如下功能

- 批量拉去并解包UEFI固件
- 拉起IDA并执行我们的插件
- 以哈希作为标签将插件结果保存在预设的Work Space的不同子目录中

### 3.7 用户界面与报告生成

我们提供了两种不同的报告生成方式，首先可以在ida中看到针对不同插件生成的统一风格的弹窗，双击弹窗中的问题列表，可以跳转到问题代码。同时我们也支持将数据导出到报告中，以便进行进一步的自动化开发。

## 4 实验与评估

### 4.1 数据集

为了能够测试我们脚本的能力，我们选取了如Lenovo，Dell，ASUS，Intel，HP等各热门厂商公开在网上的真机固件。

### 4.2 实验设置

通过批量测试脚本，我们将固件进行自动解包和分析并放入work space中，接着我们将生成的结果与我们提前标注好的结果数据进行比对，通过这种方式来判断我们脚本发现问题的能力。

### 4.3 结果与分析

## 5 总结与展望

### 5.1 工具优势与不足

我们的工具现在能够进行辅助漏洞挖掘并让我们在大量固件中快速找到需要关注的部分，但是我们的工具仍然存在不足，首先作为一个静态数据流分析工具，我们并没有完全解决路径爆炸的问题，而是选择尽可能的缓解它。然后我们没能支持所有的架构，而是留下了一个可以扩展的架构接口。最后我们并没有实现约束传递的分析，也就是说如果一个受约束的变量被使用在另一个变量的约束中，那么这种约束应该是可以传递的，这种改进将让我们的分析进一步详细。

### 5.2 未来工作方向

我们的工具现在能够进行辅助漏洞挖掘并让我们在大量固件中快速找到需要关注的部分，但是我们的工具仍然存在不足，对于这些问题我们计划在将来完成。首先UEFI可能使用了多种不同的架构，我们预留下了架构兼容的接口，未来可以支持arm等架构，然后我们的数值启发分析还可以更加完善的理解变量可能的数值，例如如果一个受限的变量被用作另一个变量的数值约束时，这种数值约束应该是可以传递的。
